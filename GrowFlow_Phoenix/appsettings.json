{
  //This file is only left public to simplify testing.
  "profiles": {
    "GrowFlow_Phoenix": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "launchUrl": "swagger",
      "applicationUrl": "https://localhost:5001;http://localhost:5000",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    }
  },
  "LeviathanApi": {
    "BaseURL": "https://leviathan.challenge.growflow.com",
    "ProviderName": "Leviathan",
    "Endpoints": {
      "EmployeeEndpoint": "/employee",
      "CustomerEndpoint": "/customer"
    },
    "Credentials": {
      "User": {
        "Param": "ApiUser",
        "Value": "CHALLENGEUSER"
      },
      "Key": {
        "Param": "ApiKey",
        "Value": "CHALLENGEKEY"
      }
    },
    "Settings": {
      // Configures the delay time (in minutes) for the background service LeviathanSyncService to request fresh data from Leviathan API and attempt updating Phoenix entities to it.
      "SyncDelay": 5,
      /* Setting UseLocalResponse to False, configures project to make real API calls to Leviathan. Setting it to True uses local text files for testing instead of making actual API calls. 
      How to use: 
      1. Set this to false initially, to send a live request to Leviathan API. This creates a local text file, containing the API response.
      2. Send a Create employee request to Phoenix (POST /employee) using Swagger UI or Postman.
      3. Send a Get employee request to Phoenix (GET /employee/}) using Swagger UI or Postman.
      4. Set this to True for testing without bloating the live API. The project will use the previously created local text files to simulate Leviathan API responses.
      5. Manually change a value in the local text file to simulate Leviathan responding with a changed entity value that Phoenix must sync with. (e.g. , change the "FirstName" value of an employee)
      */
      "UseLocalResponse": false
    }
  }
}
